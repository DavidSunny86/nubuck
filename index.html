
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Nubuck</title>
  <meta name="author" content="plainoldcj">

  
  <meta name="description" content="Welcome! This tutorial introduces you to the basic concepts of Nubuck. Nubuck is a library for visualizing algorithms using the LEDA
library.
With &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://plainoldcj.github.io//github">
  <link href="/favicon.png" rel="icon">
  <link href="./stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Nubuck" type="application/atom+xml">
  <script src="./javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="./javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Nubuck</a></h1>
  
    <h2>Nubuck development blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:plainoldcj.github.io//github" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/30/hello-world/">Hello World</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-30T19:14:00+01:00" pubdate data-updated="true">Oct 30<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Welcome! This tutorial introduces you to the basic concepts of Nubuck.</p>

<p>Nubuck is a library for visualizing algorithms using the LEDA
library.
With GraphWin and GeoWin there are already tools included in LEDA
for easy visualization of graph algorithms and 2d computational geometry algorithms
respectively.
Nubuck tries to provide similiar features for 3d geometry algorithms.</p>

<p>Listing 1 shows a minimal Nubuck application.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Listing 1. A minimal Nubuck application
</span><span class='line'>
</span><span class='line'>#include &lt;Nubuck\nubuck.h&gt;
</span><span class='line'>
</span><span class='line'>class MyAlgorithm : public IAlgorithm {
</span><span class='line'>public:
</span><span class='line'>    IPhase* Init(const Nubuck& nubuck, const leda::GRAPH&lt;leda::d3_rat_point, int&gt;& G) {
</span><span class='line'>        return NULL;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    bool Run(void) { return false; /* do nothing special */ }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>int main(int argc, char* argv[]) {
</span><span class='line'>    return RunNubuck(argc, argv, CreateAlgorithm&lt;MyAlgorithm&gt;);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>As you can see in line 5, an algorithm is defined by implementing the <code>IAlgorithm</code> interface.
The algorithm is then passed to Nubuck by calling the function <code>RunNubuck</code>, as is shown in line 15.
At this point you let Nubuck take over control, as this function starts Nubuck&rsquo;s GUI and
only returns an exit code when you close all windows.
Okay, that&rsquo;s simple enough, let&rsquo;s cover some of the details.</p>

<p>Let&rsquo;s have a look at the call to <code>RunNubuck</code> first. You&rsquo;ll notice that it&rsquo;s third argument
is not an instance of your algorithm. Instead, <code>RunNubuck</code> takes as an argument a function
that creates your algorithm. The idea is that every time you generate new input, Nubuck uses this
function to create a new instance of your algorithm to run on that input.
So you don&rsquo;t have to worry about reinitialization when writing your algorithm.
<code>CreateAlgorithm</code> is merely a convenience template function that returns a <code>new</code>ed instance
of it&rsquo;s argument.</p>

<p>Now let&rsquo;s see how to define the algorithm itself.
When deriving from <code>IAlgorithm</code> you have to implement two methods: <code>Init</code> and <code>Run</code>.</p>

<p>The <code>Init</code> method is the first method to be called by Nubuck after the algorithm
has been created.
It takes two arguments. The first one is of type <code>const Nubuck&amp;</code> and contains the
interface that Nubuck exposes to algorithms. The second argument is the input for
the algorithm.
When you click on &ldquo;Secene/New Random&rdquo; you&rsquo;ll get a parameterized graph with no edges
and a node for every point, with the position vectors being stored as the node information.
You can think of this graph as a degenerated polyhedron.</p>

<p>Your <code>Init</code> method has to return a phase. Phases are Nubuck&rsquo;s way of structuring an algorithm
into logically independent units.
Essentially a phase has a <code>Step</code> method and a sucessor phase. So every time you click on the &ldquo;Step&rdquo; button
the <code>Step</code> method of the current phase is executed. When clicking the &ldquo;Next&rdquo; or &ldquo;Run&rdquo; buttons Nubuck
takes care of advancing your algorithm that many steps and phases.
We will omit phases in the introductory examples and come back to them later
so we just return <code>NULL</code> for now.</p>

<p>Visualization introduces inherently more work to the implementation of an algorithm.
When stepping through an algorithm you want to present the underlying ideas or details of
the computiation, not just the result.
That&rsquo;s fine and the reason you want to use something like Nubuck. Unless, however,
you really just want the result.
So instead of letting Nubuck execute your phases by essentially hitting the &ldquo;Step&rdquo; button
repeatedly you can provide an optimized version of your algorithm for the &ldquo;Run&rdquo; button.
That&rsquo;s what the <code>Run</code> method is for. We don&rsquo;t use this right now, so we return <code>false</code>
indicating that we have no optimized version of our algorithm.</p>

<p>Well, this has been a lot of text for just creating an empty algorithm.
We conclude this first example by printing a string to the logbook:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>...
</span><span class='line'>IPhase* Init(const Nubuck& nubuck, const leda::GRAPH&lt;leda::d3_rat_point, int&gt;& G) {
</span><span class='line'>  nubuck.log-&gt;printf("Hello World!\n");
</span><span class='line'>  return NULL;
</span><span class='line'>}
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>Next you&rsquo;ll learn how to draw polyhedrons. As an example we&rsquo;ll draw the convex hull of the
input points.</p>

<p>Add the following line to your <code>Init</code> method to create an empty polyhedron:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IPolyhedron* chull = nubuck.world-&gt;CreatePolyhedron();</span></code></pre></td></tr></table></div></figure>


<p>It&rsquo;s recommended, although not necessary, to give your polyhedron a name so you can
easily identify it in the outliner:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chull-&gt;SetName("Convex Hull");</span></code></pre></td></tr></table></div></figure>


<p>Next we specify how to draw the polyhedron. A polyhedron is initially invisible and
the next line tells Nubuck to render the nodes, edges and faces of the polyhedron.
Note that the flag <code>POLYHEDRON_RENDER_HULL</code> enables the drawing of faces and has
nothing to do with the convex hull that we&rsquo;d like to draw.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chull-&gt;SetRenderFlags(POLYHEDRON_RENDER_NODES | POLYEDRON_RENDER_EDGES | POLYHEDRON_RENDER_HULL);</span></code></pre></td></tr></table></div></figure>


<p>Now we compute the convex hull. Remember that LEDA represents polyhedrons as planar graphs and
therefore each object of type <code>IPolyhedron</code> has a graph which you can access using it&rsquo;s
<code>GetGraph</code> method. So we can simply use LEDA&rsquo;s <code>CONVEX_HULL</code> function to compute
the hull and store the result in the graph of our <code>chull</code> object.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// G is our input graph
</span><span class='line'>leda::list&lt;point_t&gt; L;
</span><span class='line'>leda::node n;
</span><span class='line'>forall_nodes(n, G) L.append(G[n]); 
</span><span class='line'>
</span><span class='line'>leda::CONVEX_HULL(L, chull-&gt;GetGraph());</span></code></pre></td></tr></table></div></figure>


<p>The final step is to rebuild the polyhedron using it&rsquo;s current graph:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chull-&gt;Update();</span></code></pre></td></tr></table></div></figure>


<p>And that&rsquo;s it!</p>

<p>Note that you can change the graph of a polyhedron arbitrarily and
no changes are applied to it&rsquo;s graphical representation before
calling it&rsquo;s <code>Update</code> method.</p>

<p>It&rsquo;s an important point to make, so again:
You can work with the graph of an object of type <code>IPolyhedron</code>  without restraint,
but make sure it&rsquo;s a valid polyhedron (planar) before calling <code>Update</code>.</p>

<p>Feel free to play around with the methods that <code>IPolyhedron</code> has to offer.
For instance, we could color a face of the hull in red.
Remember that a face can be specified by any edge in it&rsquo;s face cycle.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>leda::edge face = chull-&gt;GetGraph().first_edge();
</span><span class='line'>chull-&gt;SetFaceColor(face, 1.0f, 0.0f, 0.0f); // color value in RGB</span></code></pre></td></tr></table></div></figure>


<p><img src="https://dl.dropboxusercontent.com/u/56764397/Nubuck_blog/img0.png" alt="Alt text" /></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/30/hello-world/">Hello World</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - plainoldcj -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
